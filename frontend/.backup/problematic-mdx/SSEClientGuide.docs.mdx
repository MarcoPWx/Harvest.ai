import { Meta } from "@storybook/addon-docs/blocks";

export const parameters = { repoDocPath: "/docs/api/REST_API.md", repoDocLabel: "REST API" };

<Meta title="Docs/SSE Client Guide" />

This guide documents the Server-Sent Events (SSE) used by the core endpoints. Each event is sent as lines like <code>event: NAME</code> and <code>data: JSON</code>, separated by a blank line.

## /api/generate (POST)

- Accepts JSON body: <code>{ input, format, provider? }</code>
- Streaming mode: set <code>Accept: text/event-stream</code>
- JSON mode: default if <code>Accept</code> does not request SSE

### Events (SSE)

- <code>event: meta</code>
- <code>data</code>: <code>{ model: string, format: string, provider?: string, request_id?: string }</code>
- <code>event: token</code>
- <code>data</code>: <code>{ text: string }</code> (small token or word chunk)
- <code>event: final</code>
- <code>data</code>: <code>{(result, cost, quality_score, processing_time, metadata)}</code>
- <code>metadata</code> includes <code>{ format, provider?, request_id?, cached, generation_id, input_length, output_length, generated_at }</code>
- <code>event: cached</code>
- <code>data</code>: <code>{ cached: true }</code> (optional; precedes final when served from cache)
- <code>event: done</code>
- <code>data</code>: <code>{ ok: true }</code>

### Minimal client pattern

```ts
const res = await fetch("/api/generate", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Accept": "text/event-stream",
  },
  body: JSON.stringify({ input, format: "blog" }),
});
const reader = res.body!.getReader();
const decoder = new TextDecoder();
let buffer = "";
while (true) {
  const { value, done } = await reader.read();
  if (done) break;
  buffer += decoder.decode(value, { stream: true });
  let idx;
  while ((idx = buffer.indexOf("\n\n")) !== -1) {
    const raw = buffer.slice(0, idx);
    buffer = buffer.slice(idx + 2);
    const lines = raw.split("\n");
    let event = "message";
    let data = "";
    for (const line of lines) {
      if (line.startsWith("event:")) event = line.slice(6).trim();
      else if (line.startsWith("data:")) data += line.slice(5).trim();
    }
    if (!data) continue;
    let json: any = data;
    try {
      json = JSON.parse(data);
    } catch {}
    // handle events
  }
}
```

## /api/threads/[id]/messages (POST)

- Accepts JSON body: <code>{ role: 'user'|'assistant', content: string, provider? }</code>
- Streaming mode: set <code>Accept: text/event-stream</code>
- JSON mode: default if <code>Accept</code> does not request SSE

### Events (SSE)

- <code>event: meta</code>
- <code>data</code>: <code>{ model: string, thread_id: string, provider?: string }</code>
- <code>event: token</code>
- <code>data</code>: <code>{ text: string }</code>
- <code>event: final</code>
- <code>data</code>: <code>{ content: string, thread_id: string, provider?: string }</code>
- <code>event: done</code>
- <code>data</code>: <code>{ ok: true }</code>

## Error handling

- JSON error responses when not streaming (e.g., <code>429</code>, <code>500</code>) include an <code>error</code> and <code>message</code>.
- In streaming mode, gateways typically end the stream on error. Your client should be robust to truncated frames.

## Tips

- Use a correlation header like <code>X-Request-ID</code> from the client; servers can include it in <code>meta</code> and <code>metadata</code> for tracing.
- Avoid blocking work in the main UI thread; stream into a buffer and render incrementally.
- If you need to cancel, keep an <code>AbortController</code> and call <code>abort()</code>.
